# “应用程序稳态测试系统”方案设计文档

## 竞赛评测背景介绍

在信息学竞赛中，每道题目都会指定一个计算内容让选手实现。选手通过编写一段代码实现给定的功能。例如：选手需要完成一个函数`void sort(int *a, int n)`，对给定整数数组进行升序排序。

竞赛评测主要指对于信息学竞赛中的选手答案程序进行以下几个方面的测试：

* 运行时间是否符合要求
* 运行内存是否符合要求
* 运行时被测程序是否崩溃
* 运行结果是否正确

每道题目会规定以下几项内容：

* 时间限制：选手程序运行所使用的时间（user time），一旦运行时间超过限制，选手的程序不再继续运行，并记为0分（错误信息：Time Limit Exceed）
* 内存限制：选手程序所占虚拟内存的上限，任何时候申请的内存超过限制，选手的程序不再继续运行，并记为0分（错误信息：Memory Limit Exceed）

此外，对选手的答案程序还有一些一般限制。选手程序中只允许通过对指定文件的读写、以及对指定库函数的调用等题目中明确规定的方式与外部环境通信。在程序中严禁下列操作：

* 试图访问网络
* 使用fork、exec、system或其它线程/进程生成函数
* 打开或创建题目规定的输入/输出文件之外的其它文件和目录
* 运行其它程序
* 改变文件系统的访问权限
* 读写文件系统的管理信息
* 使用除读写规定的输入/输出文件之外的其它系统调用
* 捕获和处理鼠标和键盘的输入消息
* 读写计算机的输入/输出端口

## 现有环境及其缺陷

### 目前的测试方法

运行方法：在系统环境下，直接将被评测程序当做一个普通程序运行。

* 方法1：评测器工作：利用系统调用执行被评测程序，使用`time ./test`测定程序运行时间（通常规则是以用户态时间计算）。
* 方法2：被评测的算法在代码中只占用一段，代码中的其他部分（称为交互库）由评测人员撰写，以C语言为例：在交互库中，在调用待测函数前记录`clock()`，用调用后的`clock()`减去之前记录的值计算出运行时间并反馈给评分程序。这种方法测定出的程序运行时间波动很大（约10%~20%），因此在本次实验中着重对这种测时方式进行优化。

### 目前方法的缺陷

* 受到中断影响：无论受到何种中断，操作系统将会执行某些代码进行处理，这将使cache（包括TLB）受到影响。我们不关心程序是否因此减慢，而是关心这些影响是否带来了更多的随机因素。
	* 键盘、网卡等外部中断具有随机性，中断的次数、时刻是随机的，中断时执行执行到的语句也是随机的。
	* 设中断次数为$n$，则测量时间的系统误差正比于$n$，随机误差正比于$\sqrt n$。
* 内存分配：由于在运行被测程序之前系统的内存布局不确定，在发生缺页时分配到的物理页也是随机的，导致cache的行为在每次运行时会有区别。
* 当前处理器可能被安排跑其他程序，导致cache受到更大的影响。
* 其他处理器可能在同时跑程序，影响内存带宽和共享cache等。
* DMA设备等可能会占用内存带宽。

## 设计方案

### 评测状态的特征
* 在评测状态时，如果需要，则禁止一切外部中断（除了用来检测超时的时钟）。
* 在进入评测状态前，如果需要，操作系统将为其分配并调整其物理内存布局，包括存在性与连续性。
* 支持SMP以后，在评测状态时，如果需要，所有处理器仅能执行被评测程序。
* 在评测状态时，如果需要，关闭外部设备的DMA功能。

###系统调用初步设计
* `enter_judge`：参数为当前进程的一个函数指针。操作系统将阻塞当前进程，直到其他进程对当前进程调用了`accept_enter_judge`时，操作系统将安排该进程进入评测状态，并跳转到该函数指针执行。评测状态结束时，`enter_judge`将返回。
* `quit_judge`：如果当前进程在评测状态，则申请正常结束评测状态（不返回，而是跳转到当初`enter_judge`的下一条指令）；否则非法。
* `commit_judge`：立即返回。
* `accept_enter_judge`：评测的主要系统调用，参数包括：要运行的进程、允许运行的最大时间、自定义参数如：是否禁止外部中断、是否调整物理内存布局等。返回情况可能如下：
 * 如果目标进程未在`enter_judge`的阻塞状态，则立即返回失败。
 * 如果目标进程调用了`quit_judge`正常结束，则返回成功，同时返回所用的时间等信息。
 * 如果目标进程直到超过最大运行时间时没有其他事件发生，则结束目标进程的评测状态（此时目标进程的`enter_judge`将返回，而不是直接被杀死），并返回超时。
 * 如果目标进程被判定为运行错误（详见下述），则结束目标进程的评测状态，并返回运行错误。

### 分阶段实验目标

* 第一阶段：被测程序在计时状态不得产生任何系统调用和异常，否则判定被测程序运行错误；操作系统也保证不抢占，同时屏蔽任何外部中断。
* 第二阶段：如果需要，允许被测程序动态申请内存、允许读写文件操作，操作系统将尽量减小处理系统调用时的开销给计时带来的不确定性；其他同上。
* 第三阶段：如果需要，允许有换入/换出。
* 第四阶段：加入网络支持，可以作为实际评测系统的后端。
* 第五阶段：支持SMP。

## 已有相关工作分析

### OSv

* 核心思想：为在虚拟机上运行做优化
* 使用非阻塞、无锁算法等，避免循环等待
* 仅能运行JVM
* 充分信任JVM，给予其最高权限，并且深度集成

JVM对于OSv是可以信任的；我们的目标中，被测程序是不可信任的。并且，JVM对于上层应用程序的管理并没有特殊之处。

### MirageOS

* 使用OCaml编写程序，一个内核只运行一个程序
* 可运行在Xen与KVM下
* 提供各种（编程语言）库

理论上我们可以令内核仅运行被测程序，而将测试的逻辑放在操作系统中；但我们认为我们的设计更合理，这样更加通用且便于扩展（例如加入网络作为后端，否则这个也要写在操作系统中）。

### Dune

* 在Linux下，允许用户程序访问通常内核中才能使用的功能
* 开放了一些特权指令，使用VT-x技术

它仍需要作为一个进程运行在Linux中，很多问题（至少包括其他程序和Linux的影响）没有解决。

### Magenta kernel

* 该项目已改名为Zircon（2017年9月）
* 我们通读了一遍它的文档，没有找到对我们的目标有帮助的部分……

## 应用实例

以下是一个最简单的例子，来说明我们上述初步设计的系统调用是如何使用的。

```c
====== sort.h ======
void sort(int *, int);

====== sort.c ======
#include "sort.h"
void sort(int *a, int n)
{
  // 选手在这里补全
  for(int i = 0; i < n; i++)
    for(int j = 1; j < n; j++)
      if(a[j] > a[j - 1])
      {
        int t = a[j];
        a[j] = a[j - 1];
        a[j - 1] = t;
      }
}

====== Makefile ======
sort: main.c sort.c sort.h
    gcc main.c sort.c -o sort

====== main.c ======
#include <......>
#include "sort.h"
static int *a, n;
static void read_input()
{
  FILE *fin = fopen("sort.in", "r");
  fscanf(fin, "%d", &n);
  int *a = (int *) malloc(sizeof(int) * n);
  for(int i = 0; i < n; i++)
    fscanf(fin, "%d", a + i);
  close(fin);
}
static void write_output()
{
  FILE *fout = fopen("sort.out", "w");
  for(int i = 0; i < n; i++)
    fprintf(fout, "%d\n", a + i);
  close(fout);
}
static void sort_wrapper()
{
  sort(a, n);
  quit_judge();
}
int main()
{
  read_input();
  enter_judge(sort_wrapper);
  commit_judge();
  write_output();
  return 0;
}

====== judger.c ======
#include <......>
int main()
{
  int child = spawn("sort", 256 << 20);
  struct JudgeResult res;
  while(!accept_enter_judge(child, &res, 1000, ......))
    yield();
  wait(child);
  if(!has_committed(child))
    return 1;
  if(res.status != JUDGE_OK)
    return 1;
  FILE *fout = fopen("sort.out", in);
  bool correct;
  ...... // 判断输出结果是否正确
  if(!correct)
    return 1;
  return 0;
}
```

此外，我们的最终目标是加入网络驱动，这样可以作为一个真实的在线评测系统的后端。

## 组内分工

### 已完成部分

* 选题确定	于纪平、张瑞喆
* 现状调查	王逸松
* 现状测试	张瑞喆
* 交流讨论	于纪平、王逸松、张瑞喆
* 报告展示	张瑞喆
* 文档撰写	张瑞喆、于纪平、王逸松
* 框架选定	于纪平

### 计划部分

* 特殊中断	于纪平
* 中断屏蔽（权限控制）	张瑞喆
* 内存整理	张瑞喆
* 非法调用控制	王逸松
* 外设关断	于纪平

### 二期计划

* 支持动态分配内存	张瑞喆
* 支持读写文件	于纪平

### 三期计划（未分配）

* 允许动态换入内存（较大的空间限制）
* 引入网卡驱动
* 网卡驱稳定性研究

### 测试工作（均为共同完成）

* 编写例题
* 进行测试
* 控制变量进行测试
* 实验报告
